<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Interactive Ray Tracer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #0a0a0a;
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        .main-container {
            display: flex;
            height: 100vh;
        }

        .viewport {
            flex: 1;
            position: relative;
            background: #000;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }

        #canvas.dragging {
            cursor: grabbing;
        }

        .overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 10px;
            font-size: 13px;
            z-index: 100;
            min-width: 250px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(74, 144, 226, 0.3);
        }

        .interaction-hint {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(74, 144, 226, 0.2);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid rgba(74, 144, 226, 0.5);
            max-width: 300px;
        }

        .side-panel {
            width: 350px;
            background: #1a1a1a;
            border-left: 1px solid #333;
            overflow-y: auto;
            padding: 20px;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #ccc;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
        }

        button {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px 5px 5px 0;
            font-weight: 500;
            transition: all 0.2s;
        }

        button:hover {
            background: linear-gradient(135deg, #357abd, #2a5a8a);
            transform: translateY(-1px);
        }

        .value-display {
            float: right;
            color: #4a90e2;
            font-weight: 600;
            min-width: 50px;
            text-align: right;
        }

        .sphere-list {
            max-height: 200px;
            overflow-y: auto;
            background: #222;
            border-radius: 6px;
            margin-top: 10px;
        }

        .sphere-item {
            padding: 10px 15px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }

        .sphere-item:hover {
            background: #333;
        }

        .sphere-item.selected {
            background: #4a90e2;
            color: white;
        }

        .sphere-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #fff;
        }

        .delete-btn {
            background: #d32f2f;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .delete-btn:hover {
            background: #b71c1c;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="viewport">
            <canvas id="canvas"></canvas>
            <div class="overlay">
                <div><strong>üéÆ Interactive Ray Tracer</strong></div>
                <div style="margin: 10px 0;">
                    <div>FPS: <span id="fps" style="color: #50c878;">--</span></div>
                    <div>GPU Load: <span id="gpuLoad" style="color: #ff6b35;">--</span>%</div>
                    <div>Rays/Frame: <span id="rayCount" style="color: #4a90e2;">--</span>M</div>
                </div>
                <div>Selected: <span id="selectedObject">None</span></div>
                <div>Spheres: <span id="sphereCount">4</span>/16</div>
            </div>

            <div class="interaction-hint">
                <strong>üéÆ Controls:</strong><br>
                <span id="controlHints">
                    ‚Ä¢ Drag to orbit camera<br>
                    ‚Ä¢ Click spheres to select<br>
                    ‚Ä¢ Shift+drag to move objects<br>
                    ‚Ä¢ Scroll to zoom
                </span>
            </div>
        </div>

        <div class="side-panel">
            <h3 style="margin-bottom: 20px; color: #4a90e2;">üéÆ Interactive Controls</h3>

            <div class="control-group">
                <label>Quality: <span class="value-display" id="qualityValue">Medium</span></label>
                <select id="qualityPreset" onchange="setQuality(this.value)" style="width: 100%; padding: 8px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
                    <option value="low">Low (Fast)</option>
                    <option value="medium" selected>Medium</option>
                    <option value="high">High Quality</option>
                    <option value="ultra">üî• Ultra</option>
                </select>
            </div>

            <div class="control-group">
                <label>Mouse Sensitivity: <span class="value-display" id="sensitivityValue">1.0</span></label>
                <input type="range" id="mouseSensitivity" min="0.1" max="3.0" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>Animation Speed: <span class="value-display" id="animSpeedValue">1.0x</span></label>
                <input type="range" id="animationSpeed" min="0" max="3" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>Gravity: <span class="value-display" id="gravityValue">0.0</span></label>
                <input type="range" id="gravity" min="0" max="2" step="0.1" value="0.0">
            </div>

            <h4 style="margin: 20px 0 10px 0; color: #50c878;">üé≤ Add Objects</h4>
            <button onclick="addSphere('random')">üé≤ Random Sphere</button>
            <button onclick="addSphere('metal')">üîò Metal Ball</button>
            <button onclick="addSphere('glass')">üîÆ Glass Ball</button>
            <button onclick="addSphere('glow')">‚ú® Glowing Ball</button>

            <h4 style="margin: 20px 0 10px 0; color: #ff6b35;">üì¶ Scene Objects</h4>
            <div class="sphere-list" id="sphereList"></div>

            <h4 style="margin: 20px 0 10px 0; color: #ffc107;">‚ö° Physics & Effects</h4>
            <button onclick="togglePhysics()" id="physicsBtn">‚ñ∂Ô∏è Start Physics</button>
            <button onclick="addExplosion()">üí• Explosion!</button>
            <button onclick="resetScene()">üîÑ Reset Scene</button>

            <div style="margin-top: 30px; padding: 15px; background: rgba(74, 144, 226, 0.1); border-radius: 8px; font-size: 12px;">
                <strong>üí° Tips:</strong><br>
                ‚Ä¢ Click a sphere to select it<br>
                ‚Ä¢ Hold Shift and drag to move spheres<br>
                ‚Ä¢ Enable physics for realistic bouncing<br>
                ‚Ä¢ Try the explosion with gravity on!
            </div>
        </div>
    </div>

    <script>
        // Fixed shader sources
        const VERTEX_SHADER_SOURCE = `
attribute vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
}`;

        const FRAGMENT_SHADER_SOURCE = `
precision highp float;

uniform vec2 u_resolution;
uniform float u_time;
uniform vec3 u_camera;
uniform int u_samples;
uniform int u_bounces;
uniform float u_resolution_scale;
uniform float u_animation_speed;
uniform float u_gravity;

// Sphere data (up to 16 spheres)
uniform int u_sphere_count;
uniform vec3 u_sphere_positions[16];
uniform vec3 u_sphere_colors[16];
uniform vec3 u_sphere_velocities[16];
uniform float u_sphere_radii[16];
uniform float u_sphere_metallic[16];
uniform float u_sphere_emission[16];

float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

float noise(vec2 x) {
    vec2 p = floor(x);
    vec2 f = fract(x);
    f = f * f * (3.0 - 2.0 * f);
    float n = p.x + p.y * 57.0;
    return mix(mix(hash(n), hash(n + 1.0), f.x),
              mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);
}

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Hit {
    bool hit;
    float t;
    vec3 point;
    vec3 normal;
    vec3 color;
    float metallic;
    float emission;
    int objectId;
};

Hit intersectSphere(Ray ray, vec3 center, float radius, vec3 color, float metallic, float emission, int id) {
    Hit h;
    h.hit = false;
    h.objectId = id;

    vec3 oc = ray.origin - center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant >= 0.0) {
        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);
        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);
        float t = t1 > 0.001 ? t1 : (t2 > 0.001 ? t2 : -1.0);

        if (t > 0.001) {
            h.hit = true;
            h.t = t;
            h.point = ray.origin + t * ray.direction;
            h.normal = normalize(h.point - center);
            h.color = color;
            h.metallic = metallic;
            h.emission = emission;

            // Add procedural texture
            vec3 texCoord = h.point * 2.0;
            float pattern = noise(texCoord.xy + texCoord.yz);
            h.color = h.color * (0.8 + 0.2 * pattern);
        }
    }

    return h;
}

Hit intersectPlane(Ray ray, vec3 point, vec3 normal) {
    Hit h;
    h.hit = false;
    h.objectId = -1;

    float denom = dot(normal, ray.direction);
    if (abs(denom) > 1e-6) {
        float t = dot(point - ray.origin, normal) / denom;
        if (t > 0.001) {
            h.hit = true;
            h.t = t;
            h.point = ray.origin + t * ray.direction;
            h.normal = normal;

            // Checkerboard pattern
            vec2 uv = h.point.xz * 0.5;
            float checker = step(0.5, mod(floor(uv.x) + floor(uv.y), 2.0));
            float noisePattern = noise(uv * 4.0) * 0.1;
            h.color = mix(vec3(0.2), vec3(0.9), checker) + noisePattern;
            h.metallic = 0.1 + checker * 0.2;
            h.emission = 0.0;
        }
    }

    return h;
}

Hit intersectScene(Ray ray) {
    Hit closest;
    closest.hit = false;
    closest.t = 1e20;

    // Intersect all spheres
    for (int i = 0; i < 16; i++) {
        if (i >= u_sphere_count) break;

        Hit h = intersectSphere(
            ray,
            u_sphere_positions[i],
            u_sphere_radii[i],
            u_sphere_colors[i],
            u_sphere_metallic[i],
            u_sphere_emission[i],
            i
        );

        if (h.hit && h.t < closest.t) {
            closest = h;
        }
    }

    // Ground plane
    Hit ground = intersectPlane(ray, vec3(0, -3, 0), vec3(0, 1, 0));
    if (ground.hit && ground.t < closest.t) {
        closest = ground;
    }

    return closest;
}

vec3 sampleEnvironment(vec3 direction) {
    float t = 0.5 * (direction.y + 1.0);
    vec3 skyColor = mix(vec3(0.1, 0.1, 0.3), vec3(0.5, 0.7, 1.0), t);

    // Dynamic stars
    if (direction.y > 0.0) {
        vec2 uv = direction.xz / direction.y;
        float stars = step(0.97, noise(uv * 30.0 + u_time * 0.1));
        skyColor = skyColor + vec3(stars * 0.5);
    }

    return skyColor;
}

vec3 calculateLighting(Hit hit, vec3 viewDir) {
    vec3 color = vec3(0.0);

    // Multiple animated lights
    vec3 lightPos1 = vec3(
        5.0 + 3.0 * sin(u_time * u_animation_speed * 0.7),
        8.0 + 2.0 * cos(u_time * u_animation_speed * 0.5),
        5.0 + 3.0 * cos(u_time * u_animation_speed * 0.7)
    );
    vec3 lightColor1 = vec3(1.0, 0.9, 0.8);
    float lightIntensity1 = 20.0;

    vec3 lightPos2 = vec3(-6.0, 4.0, -2.0);
    vec3 lightColor2 = vec3(1.0, 0.3, 0.5);
    float lightIntensity2 = 15.0;

    // Light 1
    vec3 lightDir = lightPos1 - hit.point;
    float distance = length(lightDir);
    lightDir = normalize(lightDir);

    Ray shadowRay;
    shadowRay.origin = hit.point + hit.normal * 0.001;
    shadowRay.direction = lightDir;
    Hit shadowHit = intersectScene(shadowRay);

    if (!shadowHit.hit || shadowHit.t > distance) {
        float attenuation = lightIntensity1 / (1.0 + 0.05 * distance + 0.01 * distance * distance);
        float lambertian = max(0.0, dot(hit.normal, lightDir));
        color = color + hit.color * lightColor1 * lambertian * attenuation;

        vec3 reflectDir = reflect(-lightDir, hit.normal);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), mix(8.0, 64.0, hit.metallic));
        color = color + lightColor1 * spec * attenuation * (0.3 + hit.metallic * 0.7);
    }

    // Light 2
    lightDir = lightPos2 - hit.point;
    distance = length(lightDir);
    lightDir = normalize(lightDir);

    shadowRay.origin = hit.point + hit.normal * 0.001;
    shadowRay.direction = lightDir;
    shadowHit = intersectScene(shadowRay);

    if (!shadowHit.hit || shadowHit.t > distance) {
        float attenuation = lightIntensity2 / (1.0 + 0.05 * distance + 0.01 * distance * distance);
        float lambertian = max(0.0, dot(hit.normal, lightDir));
        color = color + hit.color * lightColor2 * lambertian * attenuation;
    }

    // Emission
    color = color + hit.color * hit.emission;

    // Ambient
    color = color + hit.color * mix(vec3(0.1, 0.1, 0.15), vec3(0.15, 0.12, 0.1), hit.metallic);

    return color;
}

vec3 trace(Ray ray, float seed) {
    vec3 color = vec3(0.0);
    vec3 throughput = vec3(1.0);

    for (int bounce = 0; bounce < 12; bounce++) {
        if (bounce >= u_bounces) break;

        Hit hit = intersectScene(ray);

        if (!hit.hit) {
            color = color + throughput * sampleEnvironment(ray.direction);
            break;
        }

        vec3 viewDir = -ray.direction;
        vec3 lighting = calculateLighting(hit, viewDir);
        color = color + throughput * lighting;

        // Reflection
        if (hit.metallic > 0.1) {
            vec3 reflectDir = reflect(ray.direction, hit.normal);

            // Add roughness-based scattering (fixed)
            float roughness = 1.0 - hit.metallic;
            float randomValue = hash(seed + float(bounce));
            vec3 randomVec = vec3(
                randomValue - 0.5,
                hash(seed + float(bounce) + 1.0) - 0.5,
                hash(seed + float(bounce) + 2.0) - 0.5
            ) * roughness * 0.2;

            reflectDir = normalize(reflectDir + randomVec);

            ray.origin = hit.point + hit.normal * 0.001;
            ray.direction = reflectDir;
            throughput = throughput * hit.color * hit.metallic;
        } else {
            break;
        }

        // Russian roulette
        float maxComponent = max(max(throughput.r, throughput.g), throughput.b);
        if (maxComponent < 0.1) {
            if (hash(seed + float(bounce)) > maxComponent) break;
            throughput = throughput / maxComponent;
        }
    }

    return color;
}

void main() {
    vec2 coord = gl_FragCoord.xy * u_resolution_scale;
    vec2 screenPos = (coord / u_resolution) * 2.0 - 1.0;
    screenPos.x = screenPos.x * (u_resolution.x / u_resolution.y);

    vec3 color = vec3(0.0);
    vec3 rayOrigin = u_camera;

    // Multi-sampling
    for (int sample = 0; sample < 16; sample++) {
        if (sample >= u_samples) break;

        float jitterX = hash(coord.x + float(sample) * 0.1) - 0.5;
        float jitterY = hash(coord.y + float(sample) * 0.1 + 100.0) - 0.5;
        vec2 jitter = vec2(jitterX, jitterY) * 2.0 / u_resolution;

        vec2 samplePos = screenPos + jitter;
        vec3 rayDir = normalize(vec3(samplePos, -1.0));

        Ray ray;
        ray.origin = rayOrigin;
        ray.direction = rayDir;

        float seed = coord.x + coord.y + float(sample) + u_time;
        color = color + trace(ray, seed);
    }

    color = color / float(u_samples);

    // Post-processing
    float brightness = dot(color, vec3(0.299, 0.587, 0.114));
    if (brightness > 1.0) {
        color = color + (color - 1.0) * 0.5;
    }

    // Tone mapping and gamma
    color = color / (1.0 + color);
    color = pow(color, vec3(1.0 / 2.2));

    gl_FragColor = vec4(color, 1.0);
}`;

        class FixedInteractiveRayTracer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.debug = [];

                this.initScene();

                try {
                    this.log('Starting fixed interactive ray tracer...');
                    this.resizeCanvas();
                    this.initWebGL();
                    this.createShaders();
                    this.setupControls();
                    this.setupStats();
                    this.setupMouseControls();
                    this.setupPhysics();
                    this.log('‚úÖ Ray tracer initialized successfully!');
                    this.animate();
                } catch (error) {
                    this.showError(error);
                }
            }

            initScene() {
                this.camera = [0, 2, 12];
                this.cameraTarget = [0, 0, -5];
                this.cameraAngleX = 0;
                this.cameraAngleY = 0;

                this.spheres = [
                    {
                        position: [-3, 1, -5],
                        velocity: [0, 0, 0],
                        radius: 1.0,
                        color: [0.9, 0.1, 0.1],
                        metallic: 0.9,
                        emission: 0.0,
                        mass: 1.0
                    },
                    {
                        position: [3, 1, -5],
                        velocity: [0, 0, 0],
                        radius: 1.0,
                        color: [0.1, 0.9, 0.1],
                        metallic: 0.0,
                        emission: 0.0,
                        mass: 1.0
                    },
                    {
                        position: [0, 3, -3],
                        velocity: [0, 0, 0],
                        radius: 0.8,
                        color: [0.9, 0.5, 0.1],
                        metallic: 0.2,
                        emission: 2.0,
                        mass: 0.8
                    },
                    {
                        position: [0, 0, -8],
                        velocity: [1, 0.5, 0],
                        radius: 0.6,
                        color: [0.1, 0.5, 0.9],
                        metallic: 0.8,
                        emission: 0.0,
                        mass: 0.6
                    }
                ];

                this.settings = {
                    resolution: 1.0,
                    samples: 4,
                    bounces: 6,
                    mouseSensitivity: 1.0,
                    animationSpeed: 1.0,
                    gravity: 0.0,
                    physicsEnabled: false
                };

                this.selectedSphere = -1;
                this.isDragging = false;
                this.updateSphereList();
            }

            log(message) {
                console.log(message);
                this.debug.push(message);
            }

            showError(error) {
                console.error('Ray tracer error:', error);
                document.body.innerHTML = `
                    <div style="padding: 40px; color: white; background: #1a1a1a; text-align: center; height: 100vh; display: flex; flex-direction: column; justify-content: center;">
                        <h2>üö® Ray Tracer Failed</h2>
                        <p style="color: #ff6b6b; margin: 20px 0;"><strong>Error:</strong> ${error.message}</p>
                        <button onclick="window.location.reload()" style="margin-top: 20px; padding: 15px 30px; background: #4a90e2; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 16px;">
                            üîÑ Try Again
                        </button>
                    </div>
                `;
            }

            resizeCanvas() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            initWebGL() {
                this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
                if (!this.gl) {
                    throw new Error('WebGL not supported');
                }
                this.log(`WebGL initialized: ${this.gl.getParameter(this.gl.VERSION)}`);
            }

            createShaders() {
                this.log('Creating shaders...');
                this.program = this.createProgram(VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE);
                this.getUniforms();
                this.createGeometry();
            }

            createProgram(vertexSource, fragmentSource) {
                const gl = this.gl;

                const vertexShader = this.compileShader(gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fragmentSource);

                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error(`Program link failed: ${gl.getProgramInfoLog(program)}`);
                }

                return program;
            }

            compileShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);

                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    const error = gl.getShaderInfoLog(shader);
                    gl.deleteShader(shader);
                    throw new Error(`Shader compilation failed: ${error}`);
                }

                return shader;
            }

            getUniforms() {
                const gl = this.gl;
                this.uniforms = {};

                const names = [
                    'u_resolution', 'u_time', 'u_camera', 'u_samples', 'u_bounces',
                    'u_resolution_scale', 'u_animation_speed', 'u_gravity', 'u_sphere_count'
                ];

                names.forEach(name => {
                    this.uniforms[name] = gl.getUniformLocation(this.program, name);
                });

                // Get array uniform locations
                for (let i = 0; i < 16; i++) {
                    this.uniforms[`u_sphere_positions[${i}]`] = gl.getUniformLocation(this.program, `u_sphere_positions[${i}]`);
                    this.uniforms[`u_sphere_colors[${i}]`] = gl.getUniformLocation(this.program, `u_sphere_colors[${i}]`);
                    this.uniforms[`u_sphere_velocities[${i}]`] = gl.getUniformLocation(this.program, `u_sphere_velocities[${i}]`);
                    this.uniforms[`u_sphere_radii[${i}]`] = gl.getUniformLocation(this.program, `u_sphere_radii[${i}]`);
                    this.uniforms[`u_sphere_metallic[${i}]`] = gl.getUniformLocation(this.program, `u_sphere_metallic[${i}]`);
                    this.uniforms[`u_sphere_emission[${i}]`] = gl.getUniformLocation(this.program, `u_sphere_emission[${i}]`);
                }
            }

            createGeometry() {
                const gl = this.gl;
                const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);

                this.vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            }

            setupMouseControls() {
                let isMouseDown = false;
                let lastMouseX = 0;
                let lastMouseY = 0;
                let shiftPressed = false;

                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Shift') shiftPressed = true;
                });

                window.addEventListener('keyup', (e) => {
                    if (e.key === 'Shift') shiftPressed = false;
                });

                this.canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;

                    if (shiftPressed) {
                        const sphere = this.getObjectAtMouse(e.clientX, e.clientY);
                        if (sphere !== -1) {
                            this.selectedSphere = sphere;
                            this.isDragging = true;
                            this.canvas.classList.add('dragging');
                            this.updateSelectedObject();
                        }
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (!isMouseDown) return;

                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;

                    if (this.isDragging && this.selectedSphere !== -1) {
                        const sensitivity = this.settings.mouseSensitivity * 0.02;
                        this.spheres[this.selectedSphere].position[0] += deltaX * sensitivity;
                        this.spheres[this.selectedSphere].position[1] -= deltaY * sensitivity;

                        this.spheres[this.selectedSphere].velocity[0] = deltaX * sensitivity * 10;
                        this.spheres[this.selectedSphere].velocity[1] = -deltaY * sensitivity * 10;
                    } else {
                        const sensitivity = this.settings.mouseSensitivity * 0.01;
                        this.cameraAngleY += deltaX * sensitivity;
                        this.cameraAngleX += deltaY * sensitivity;
                        this.cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.cameraAngleX));

                        this.updateCameraPosition();
                    }

                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });

                this.canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                    this.isDragging = false;
                    this.canvas.classList.remove('dragging');
                });

                this.canvas.addEventListener('click', (e) => {
                    if (!shiftPressed) {
                        const sphere = this.getObjectAtMouse(e.clientX, e.clientY);
                        this.selectedSphere = sphere;
                        this.updateSelectedObject();
                        this.updateSphereList();
                    }
                });

                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const forward = this.normalizeVector(this.subtractVectors(this.cameraTarget, this.camera));
                    const zoomSpeed = 0.5;

                    this.camera[0] += forward[0] * e.deltaY * zoomSpeed * 0.01;
                    this.camera[1] += forward[1] * e.deltaY * zoomSpeed * 0.01;
                    this.camera[2] += forward[2] * e.deltaY * zoomSpeed * 0.01;
                });
            }

            getObjectAtMouse(mouseX, mouseY) {
                const rect = this.canvas.getBoundingClientRect();
                const x = ((mouseX - rect.left) / rect.width) * 2 - 1;
                const y = (1 - (mouseY - rect.top) / rect.height) * 2 - 1;

                const rayDir = this.normalizeVector([x * (rect.width / rect.height), y, -1]);

                let closestSphere = -1;
                let closestDistance = Infinity;

                for (let i = 0; i < this.spheres.length; i++) {
                    const sphere = this.spheres[i];
                    const toSphere = this.subtractVectors(sphere.position, this.camera);
                    const projectionLength = this.dotProduct(toSphere, rayDir);

                    if (projectionLength > 0) {
                        const closestPoint = [
                            this.camera[0] + rayDir[0] * projectionLength,
                            this.camera[1] + rayDir[1] * projectionLength,
                            this.camera[2] + rayDir[2] * projectionLength
                        ];

                        const distance = this.vectorLength(this.subtractVectors(closestPoint, sphere.position));

                        if (distance < sphere.radius && projectionLength < closestDistance) {
                            closestSphere = i;
                            closestDistance = projectionLength;
                        }
                    }
                }

                return closestSphere;
            }

            updateCameraPosition() {
                const radius = this.vectorLength(this.subtractVectors(this.camera, this.cameraTarget));
                this.camera = [
                    this.cameraTarget[0] + radius * Math.sin(this.cameraAngleY) * Math.cos(this.cameraAngleX),
                    this.cameraTarget[1] + radius * Math.sin(this.cameraAngleX),
                    this.cameraTarget[2] + radius * Math.cos(this.cameraAngleY) * Math.cos(this.cameraAngleX)
                ];
            }

            setupPhysics() {
                this.lastPhysicsTime = performance.now();
            }

            updatePhysics() {
                if (!this.settings.physicsEnabled) return;

                const now = performance.now();
                const deltaTime = (now - this.lastPhysicsTime) * 0.001 * this.settings.animationSpeed;
                this.lastPhysicsTime = now;

                for (let i = 0; i < this.spheres.length; i++) {
                    const sphere = this.spheres[i];

                    // Apply gravity
                    sphere.velocity[1] -= this.settings.gravity * deltaTime;

                    // Apply air resistance
                    sphere.velocity[0] *= 0.99;
                    sphere.velocity[1] *= 0.99;
                    sphere.velocity[2] *= 0.99;

                    // Update position
                    sphere.position[0] += sphere.velocity[0] * deltaTime;
                    sphere.position[1] += sphere.velocity[1] * deltaTime;
                    sphere.position[2] += sphere.velocity[2] * deltaTime;

                    // Ground collision
                    if (sphere.position[1] - sphere.radius < -3) {
                        sphere.position[1] = -3 + sphere.radius;
                        sphere.velocity[1] = Math.abs(sphere.velocity[1]) * 0.8;
                    }

                    // Sphere-sphere collisions
                    for (let j = i + 1; j < this.spheres.length; j++) {
                        const other = this.spheres[j];
                        const distance = this.vectorLength(this.subtractVectors(sphere.position, other.position));
                        const minDistance = sphere.radius + other.radius;

                        if (distance < minDistance) {
                            const overlap = minDistance - distance;
                            const direction = this.normalizeVector(this.subtractVectors(sphere.position, other.position));

                            sphere.position[0] += direction[0] * overlap * 0.5;
                            sphere.position[1] += direction[1] * overlap * 0.5;
                            sphere.position[2] += direction[2] * overlap * 0.5;

                            other.position[0] -= direction[0] * overlap * 0.5;
                            other.position[1] -= direction[1] * overlap * 0.5;
                            other.position[2] -= direction[2] * overlap * 0.5;

                            const tempVel = [...sphere.velocity];
                            sphere.velocity = [...other.velocity];
                            other.velocity = tempVel;
                        }
                    }
                }
            }

            setupControls() {
                window.setQuality = (preset) => {
                    const settings = {
                        low: { resolution: 0.75, samples: 2, bounces: 4 },
                        medium: { resolution: 1.0, samples: 4, bounces: 6 },
                        high: { resolution: 1.25, samples: 8, bounces: 8 },
                        ultra: { resolution: 1.5, samples: 12, bounces: 10 }
                    };

                    Object.assign(this.settings, settings[preset]);
                    document.getElementById('qualityValue').textContent =
                        preset.charAt(0).toUpperCase() + preset.slice(1);
                };

                window.addSphere = (type) => this.addSphere(type);
                window.deleteSphere = (index) => this.deleteSphere(index);
                window.resetScene = () => this.resetScene();
                window.togglePhysics = () => this.togglePhysics();
                window.addExplosion = () => this.addExplosion();

                this.setupSlider('mouseSensitivity', (v) => v.toFixed(1));
                this.setupSlider('animationSpeed', (v) => `${v}x`);
                this.setupSlider('gravity', (v) => v.toFixed(1));
            }

            setupSlider(id, formatter) {
                const slider = document.getElementById(id);
                const display = document.getElementById(id + 'Value');

                if (slider && display) {
                    slider.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        this.settings[id] = value;
                        display.textContent = formatter ? formatter(value) : value;
                    });
                }
            }

            addSphere(type) {
                if (this.spheres.length >= 16) return;

                const types = {
                    random: () => ({
                        color: [Math.random(), Math.random(), Math.random()],
                        metallic: Math.random(),
                        emission: Math.random() < 0.2 ? Math.random() * 2 : 0
                    }),
                    metal: () => ({ color: [0.9, 0.9, 0.95], metallic: 0.95, emission: 0 }),
                    glass: () => ({ color: [0.9, 0.95, 1.0], metallic: 0.1, emission: 0 }),
                    glow: () => ({ color: [1.0, 0.7, 0.3], metallic: 0.0, emission: 3.0 })
                };

                const config = types[type]();
                this.spheres.push({
                    position: [
                        (Math.random() - 0.5) * 6,
                        Math.random() * 3 + 1,
                        -8 + (Math.random() - 0.5) * 4
                    ],
                    velocity: [0, 0, 0],
                    radius: 0.5 + Math.random() * 0.8,
                    color: config.color,
                    metallic: config.metallic,
                    emission: config.emission,
                    mass: 1.0
                });

                this.updateSphereList();
            }

            deleteSphere(index) {
                if (index >= 0 && index < this.spheres.length) {
                    this.spheres.splice(index, 1);
                    if (this.selectedSphere === index) {
                        this.selectedSphere = -1;
                    } else if (this.selectedSphere > index) {
                        this.selectedSphere--;
                    }
                    this.updateSphereList();
                    this.updateSelectedObject();
                }
            }

            togglePhysics() {
                this.settings.physicsEnabled = !this.settings.physicsEnabled;
                document.getElementById('physicsBtn').textContent =
                    this.settings.physicsEnabled ? '‚è∏Ô∏è Pause Physics' : '‚ñ∂Ô∏è Start Physics';
            }

            addExplosion() {
                const center = [0, 0, -5];
                const force = 15;

                this.spheres.forEach(sphere => {
                    const direction = this.normalizeVector(this.subtractVectors(sphere.position, center));
                    const distance = this.vectorLength(this.subtractVectors(sphere.position, center));
                    const strength = force / (1 + distance);

                    sphere.velocity[0] += direction[0] * strength;
                    sphere.velocity[1] += direction[1] * strength;
                    sphere.velocity[2] += direction[2] * strength;
                });
            }

            resetScene() {
                this.initScene();
            }

            updateSphereList() {
                const list = document.getElementById('sphereList');
                list.innerHTML = '';

                this.spheres.forEach((sphere, index) => {
                    const item = document.createElement('div');
                    item.className = `sphere-item ${index === this.selectedSphere ? 'selected' : ''}`;
                    item.onclick = () => {
                        this.selectedSphere = index;
                        this.updateSphereList();
                        this.updateSelectedObject();
                    };

                    const colorStyle = `rgb(${Math.floor(sphere.color[0] * 255)}, ${Math.floor(sphere.color[1] * 255)}, ${Math.floor(sphere.color[2] * 255)})`;

                    item.innerHTML = `
                        <span>Sphere ${index + 1}</span>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <div class="sphere-color" style="background: ${colorStyle};"></div>
                            <button class="delete-btn" onclick="event.stopPropagation(); deleteSphere(${index})">√ó</button>
                        </div>
                    `;

                    list.appendChild(item);
                });

                document.getElementById('sphereCount').textContent = this.spheres.length;
            }

            updateSelectedObject() {
                const objectName = this.selectedSphere === -1 ? 'None' : `Sphere ${this.selectedSphere + 1}`;
                document.getElementById('selectedObject').textContent = objectName;
            }

            setupStats() {
                this.fpsHistory = new Array(60).fill(0);
                this.fpsIndex = 0;
                this.lastTime = performance.now();
            }

            updateStats() {
                const now = performance.now();
                const frameTime = now - this.lastTime;
                this.lastTime = now;

                this.fpsHistory[this.fpsIndex] = 1000 / frameTime;
                this.fpsIndex = (this.fpsIndex + 1) % this.fpsHistory.length;

                const fps = this.fpsHistory.reduce((a, b) => a + b) / this.fpsHistory.length;
                const gpuLoad = Math.min(100, Math.max(0, 100 - fps * 1.67));

                document.getElementById('fps').textContent = fps.toFixed(1);
                document.getElementById('gpuLoad').textContent = gpuLoad.toFixed(0);
                document.getElementById('rayCount').textContent = (this.canvas.width * this.canvas.height * this.settings.samples / 1000000).toFixed(1);
            }

            render() {
                this.updatePhysics();

                const gl = this.gl;

                try {
                    gl.useProgram(this.program);

                    // Bind geometry
                    const positionLocation = gl.getAttribLocation(this.program, 'a_position');
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                    gl.enableVertexAttribArray(positionLocation);
                    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

                    // Set uniforms
                    if (this.uniforms.u_resolution) gl.uniform2f(this.uniforms.u_resolution, this.canvas.width, this.canvas.height);
                    if (this.uniforms.u_time) gl.uniform1f(this.uniforms.u_time, performance.now() * 0.001);
                    if (this.uniforms.u_camera) gl.uniform3fv(this.uniforms.u_camera, this.camera);
                    if (this.uniforms.u_samples) gl.uniform1i(this.uniforms.u_samples, this.settings.samples);
                    if (this.uniforms.u_bounces) gl.uniform1i(this.uniforms.u_bounces, this.settings.bounces);
                    if (this.uniforms.u_resolution_scale) gl.uniform1f(this.uniforms.u_resolution_scale, this.settings.resolution);
                    if (this.uniforms.u_animation_speed) gl.uniform1f(this.uniforms.u_animation_speed, this.settings.animationSpeed);
                    if (this.uniforms.u_gravity) gl.uniform1f(this.uniforms.u_gravity, this.settings.gravity);
                    if (this.uniforms.u_sphere_count) gl.uniform1i(this.uniforms.u_sphere_count, this.spheres.length);

                    // Sphere data
                    for (let i = 0; i < Math.min(this.spheres.length, 16); i++) {
                        const sphere = this.spheres[i];

                        if (this.uniforms[`u_sphere_positions[${i}]`])
                            gl.uniform3fv(this.uniforms[`u_sphere_positions[${i}]`], sphere.position);
                        if (this.uniforms[`u_sphere_colors[${i}]`])
                            gl.uniform3fv(this.uniforms[`u_sphere_colors[${i}]`], sphere.color);
                        if (this.uniforms[`u_sphere_velocities[${i}]`])
                            gl.uniform3fv(this.uniforms[`u_sphere_velocities[${i}]`], sphere.velocity);
                        if (this.uniforms[`u_sphere_radii[${i}]`])
                            gl.uniform1f(this.uniforms[`u_sphere_radii[${i}]`], sphere.radius);
                        if (this.uniforms[`u_sphere_metallic[${i}]`])
                            gl.uniform1f(this.uniforms[`u_sphere_metallic[${i}]`], sphere.metallic);
                        if (this.uniforms[`u_sphere_emission[${i}]`])
                            gl.uniform1f(this.uniforms[`u_sphere_emission[${i}]`], sphere.emission);
                    }

                    // Render
                    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                } catch (error) {
                    console.error('Render error:', error);
                }
            }

            animate() {
                this.render();
                this.updateStats();
                requestAnimationFrame(() => this.animate());
            }

            // Vector utility functions
            vectorLength(v) {
                return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            }

            normalizeVector(v) {
                const len = this.vectorLength(v);
                return len > 0 ? [v[0] / len, v[1] / len, v[2] / len] : [0, 0, 0];
            }

            subtractVectors(a, b) {
                return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
            }

            dotProduct(a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            }
        }

        // Initialize
        window.addEventListener('load', () => {
            new FixedInteractiveRayTracer();
        });
    </script>
</body>
</html>